#!/usr/bin/env python
# coding=utf-8
import re
import sys
import zlib

# Convert Deciphere cosmic duke containers to file (tsk)


# Functions
def getparam(count):
    if len(sys.argv) != count+1:
        print 'Convert Duke TSK container to file'
        print 'To Use: ' + sys.argv[0] + ' my params'
        sys.exit(1)
    else:
        return sys.argv[1]


''' Original code


#define HASHSIZE    4096    /* must be a power of 2 */
#define HASHMASK    (HASHSIZE - 1)
#define SEQLEN      0xfff   /* max length of a sequence of equal chars */

#define BufferMaxSize   32768;
#define BufferMax   (BufferMaxSize-1)
#define FLAG_Copied 0x80
#define FLAG_Compress   0x40
#define HASH_EMPTY  -1

#define BYTE    unsigned char
#define WORD    unsigned short

#define HI(x)   (((x)>>8) & 0xff)
#define LO(x)   ((x) & 0xff)

/*
 * words are stored MSB first. The header is made as follows:
 *
 *  MSB  +----+----+----+----+ LSB
 *  POS   xxxx xxxx xxxx
 *  SIZE             xxxx
 */
#if 1
#   define  PUTWORD(destp,w) (*(destp) = HI(w), *(destp+1) = LO(w))
#   define  GETWORD(srcp) ((*(srcp) <<8) + (*(srcp+1)))
#   define  GETSIZE(srcp) ((*(srcp+1) & 0xf))
#   define  GETPOS(srcp) ( (*(srcp) << 4) + (*(srcp+1) >> 4) )
#else
#   define  PUTWORD(destp,w) *(WORD *)(destp) = (w)
#   define  GETWORD(srcp) *(WORD *)(srcp)
#   define  GETSIZE(srcp) (GETWORD(srcp) & 0x0f)
#   define  GETPOS(srcp) (GETWORD(srcp) >> 4)
#endif




int lzrw1_decompr(BYTE src[], int SourceSize, BYTE dst[])
{
    int
    i,
    size,
    Pos;
    unsigned long Command=0; /* this is a trick to avoid using a bit counter */
    BYTE *dst_ptr= dst;
    BYTE *src_ptr= src+1,
    *src_lim = src + SourceSize;

    if (src[0] == FLAG_Copied) {
    memcpy(dst,src+1, SourceSize-1);
    return SourceSize-1;
    }
    while (src_ptr < src_lim) {
    if (Command == 0) {
        Command = GETWORD(src_ptr) | 0x10000UL;
        src_ptr +=2;
    }
    if ((Command & 0x8000) == 0) {
        *dst_ptr++ = *src_ptr++;
    }
    else {
        Pos = GETPOS(src_ptr);
        if (Pos == 0) {
        size = GETWORD(src_ptr+1) + 16;
        for (; size ; size--)
              *dst_ptr++ = src_ptr[3];
        src_ptr +=4;
        }
        else {
        size = GETSIZE(src_ptr)+3;
#if 0   /* don't know why, this doesn't work */
        bcopy(dst_ptr-Pos, dst_ptr, size);
        i=size;
#else
        for (i = 0 ; i < size ; i++)
             dst_ptr[i] = dst_ptr[-Pos+i];
#endif
        src_ptr += 2;
        dst_ptr += size;
        }
    }
    Command += Command; /* SHL */
    Command &= ~0x10000UL;
    }
    return dst_ptr - dst;
}
'''


# un_lzrw1(src, dest)
    SourceSize = len(bytearray(src))
    i, size, pos, command = 0, 0, 0, 0
    FLAG_Copied = 0x80
        

    if (src[0] == FLAG_Copied):
        for i in range(SourceSize):
            dst[i] = src[i] + 1
    
    while (src_ptr < SourceSize):
        Main


# Main Code #####
def main():
    filename = getparam(1)
    filedata = open(filename, "rb").read()

    filedata = zlib.decompress(filedata)

    ofile = open(("%s__%s" % (filename, "extract")), "w")
    ofile.write(filedata)
    ofile.close


if __name__ == '__main__':
    main()
