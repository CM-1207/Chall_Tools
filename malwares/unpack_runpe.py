# Python script to unpack RUNPE 32 Bits samples
# Work on x64dbg

from _x64dbg import *
import time
from ctypes import *

# As Admin for all python instances 32/64 as XX
# pythonXX https://bootstrap.pypa.io/get-pip.py
# /pathto/pythonXX/python pip install pefile
import pefile

bps = [('msvcrt', 'printf'), ('kernel32', 'CreateRemoteThread'),
       ('ntdll.dll', 'NtWriteVirtualMemory'), ('Kernel32', 'WriteProcessMemory'),
       ('Kernel32.dll', 'LoadLibraryA'), ('Kernel32.dll', 'LoadLibraryExA'),
       ('Kernel32.dll', 'LoadLibraryExW'), ('Kernel32.dll', 'LoadLibraryW'),
       ('Kernel32.dll', 'ResumeThread'), ('Kernel32.dll', 'CreateProcessA'),
       ('Kernel32.dll', 'CreateProcessW')]
outbp = {}


def get_string(base, max_str=512):
    bytebuffer = bytearray()
    for offset in range(max_str + 1):
        byte = ReadByte(base + offset)
        if byte == 0:
            break
        bytebuffer.append(byte)
    return str(bytebuffer)


def get_segment(address):
    base = GetBase(address, False, False)
    slen = GetSize(base, False, False)
    return (base, slen)


def resume():
    DbgCmdExecDirect("run")  # Run as is for thread issues


def read_buffer(addr, size):
    read_bytes = bytearray(size)
    result, read_size = Memory_Read(addr, read_bytes, size)
    return bytes(read_bytes[:read_size])


def find_pe(addr, size):
    filearray = read_buffer(addr, size)
    filearray = bytearray(filearray)
    dumped = False
    for M in range(0, len(filearray) - 1):
        if int(filearray[M]) == ord('M') and int(filearray[M + 1]) == ord('Z'):
            try:
                PE = pefile.PE(data="".join(chr(b) for b in filearray[M::]))
                for section in PE.sections:    # va chercher les data la dernierse section fait fois
                    location = section.PointerToRawData
                    locationadd = section.SizeOfRawData
                Z = location + locationadd
                name = 'PE_at_0x%x_in_0x%x.exe' % (M, addr)
                with open(name, 'wb') as outfile:
                    outfile.write(filearray[M:M + Z])
                dumped = True
                print ('Dumped %s %d bytes saved' % (name, Z))
                outfile.close()
            except:
                pass
    return dumped


def bpcallback():
    """ Called on breakpoint """
    eip = GetEIP()  # Current EIP
    seip = ReadDword(GetESP())   # -5 pour top stack
    if seip < 0x70000000:  # Not called from kernel32.dll
        print "--> 0x%x call %s in %s" % (seip, outbp[eip][1], outbp[eip][0])
        setallbp()

    # Block Halt thread resuming
    if outbp[eip][1] in ['ResumeThread']:
        print "--> Task Resumed request : dump it !"
        pass

    # Detect PE during memory copy
    elif outbp[eip][1] in ['WriteProcessMemory']:
        ptrstr = ReadDword(GetESP() + 12)  # Offset Source
        exestr = ReadWord(ptrstr)
        base, slen = get_segment(ptrstr)
        print "-->Section involved 0x%x for 0x%x bytes" % (base, slen)
        if exestr == 0x5a4d:  # MZ
            print "--> MZ Found in source at 0x%x" % (ptrstr)
            find_pe(base, slen)
        else:
            # Toto decrotte pe ici
            find_pe(base, slen)
        resume()

    # Print out the name of the process created
    elif outbp[eip][1] in ['CreateProcessA', 'CreateProcessW']:
        ptrstr = ReadDword(GetESP() + 4)
        print "--> Exec Param at 0x%x %s" % (ptrstr, get_string(ptrstr))
        resume()
    else:
        resume()


def setallbp():
    """ Set all breakpoints """
    global outbp
    for bp in bps:
        eip = pluginsdk.RemoteGetProcAddress(bp[0], bp[1])
        if eip != 0:
            if eip not in outbp:
                outbp[eip] = (bp[0], bp[1])
                print "--> Breaking %s" % bp[1]
                Breakpoint.add(eip, bpcallback)

# Set breakpoints
GuiLogClear()
setallbp()
