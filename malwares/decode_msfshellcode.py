#!/usr/bin/env python
# coding=utf-8
import re
import sys
import base64
import zlib

# Decode powershell dropper... (n iteration of gzip/base64) + metasploit


# Functions
def getparam(count):
    if len(sys.argv) != count + 1:
        print 'Find ip from a MSF Stage0 unobfuscated shellcode'
        print 'To Use: ' + sys.argv[0] + ' my params'
        sys.exit(1)
    else:
        return sys.argv[1]


# c code.activestate.com
def toHex(s):
    lst = []
    for ch in s:
        hv = hex(ord(ch)).replace('0x', '')
        if len(hv) == 1:
            hv = '0'+hv
        lst.append(hv)
    return reduce(lambda x, y: x+y, lst)


def i2d(s):
    return str(ord(s))


# Iterator that give all position of a given pattern (no regex)
def findall(pat, data):
    i = data.find(pat)
    while i != -1:
        yield i
        i = data.find(pat, i+1)


# Find MSF Shellcode
def findshell(buff):
    # Found Reverse TCP
    for i in findall('\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f', buff):
        print "Found push ws_32.dll at offset %d" % (i)
        candidate = buff[i-128:i+128]
        found = re.search('\x6a.\x68(?P<ip>....)\x68\x02\x00(?P<port>..)\x89\xe6', candidate, re.S | re.M)
        if found:
            ip = i2d(found.group('ip')[0:1]) + "." + i2d(found.group('ip')[1:2]) + "." +\
                 i2d(found.group('ip')[2:3]) + "." + i2d(found.group('ip')[3:4])
            port = int(i2d(found.group('port')[0:1])) * 256 + int(i2d(found.group('port')[1:2]))
            print "* FOUND Reverse TCP to %s:%d" % (ip, port)

    # Found Reverse HTTPS
    for i in findall('\x68\x80\x33\x00\x00\x89\xe0\x6a\x04\x50\x6a\x1f\x56\x68\x75\x46\x9e\x86\xff\xd5', buff):
        print "Found push wininet.dll InternetSetOptionA at offset %d" % (i)
        candidate = buff[i-190:i+190]

        found = re.search('\xff\xd5\x53\x53\x6a\x03\x53\x53\x68(?P<port>..)\x00\x00' +
                          '\xe8....(?P<uri>(\S+))\x00\x50\x68\x57' + '.+' +
                          '\x85\xc0\x75.\x58\xc3\x5f\xe8....(?P<host>(\S+))\x00\x53\xff\xd5',
                          candidate, re.S | re.M)
        if found:
            host = found.group('host').split('\x00')[0]
            uri = found.group('uri').split('\x00')[0]
            port = int(i2d(found.group('port')[1:2])) * 256 + int(i2d(found.group('port')[0:1]))
            # Split due to greedyness
            print "* FOUND Reverse HTTPS to https://%s:%d%s" % (host, port, uri)


def dezip(buff):
    try:
        # Clean GZIP file
        return(zlib.decompress(buff, 16+zlib.MAX_WBITS))
    except:
        try:
            print "Not a Gzip"
            # Gzip without headers
            return(zlib.decompress(buff, -15))
        except:
            print "Not a headless Gzip"
            # Plain data...
            return(buff)


def getb64(buff):
    if buff[0:2] == "\xff\xfe":
        print "16 bytes Unicode File detected"
        buff = buff[2::].decode('utf-16', 'ignore')
        buff = bytes(buff)
    occurences = re.findall('(?P<b64>[a-zA-Z0-9+\/]{128,}={0,2})', buff, re.M)
    if occurences:
        print ("Found %d Base64 string" % len(occurences))
        for occurence in occurences:
            print "Analyse B64 occurence %s…" % occurence[0:15]
            occurence = dezip(base64.b64decode(occurence))  # Try to unzip stream
            findshell(occurence)
            if re.search('([a-zA-Z0-9+\/]{128,}={0,2})', occurence):  # IF remaining B64 recurse call
                print "Found B64 in B64.. step in again"
                getb64(occurence)


# Main Code #####
def main():
    sfile = getparam(1)
    buff = open(sfile, 'r').read()
    findshell(buff)  # Try Raw extract
    getb64(buff)  # Try B64 Extracts

if __name__ == '__main__':
    main()
